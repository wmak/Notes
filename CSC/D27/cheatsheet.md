# Symmetric Crytography
- Shift Ciphers
  - Replace each letter with the letter x letters down.
- Monoalphabetic cipher
  - Single substitution alphabet
  - 4x10^26 keys
  - Frequency Analysis
    - Satistical Cryptanalysis in general
- Vingenère Cipher
  - Use a keyword
  - Repeat the keyword and use that as shift
  - Obscures against frequency analysis
- OTP
  - Theoretically unbreakable
- Playfair Block Cipher
  - Create a 5x5 matrix of letters
  - I == J
- Feistel Cipher
  - do n rounds, on L and R halves of input
  - Encrypt one half, and use that to encrypt other half
  - Repeat.
- DES
  - Type of Feistel cipher
  - 16 rounds
  - 56 bit keys
  - 64 bit blocks
- 2DES
  - Use 2 56 bit keys (112 bits)
  - Increases key space to 112 bit keys
  - Meet-In-The-Middle Attack
    - C = E(K2, E(K1, P))
    - P = D(K1, D(K2, C))
    - E(K1, P) = X = D(K2, C)
- 3DES
  - Use 2 Keys
    - C = E(K1, D(K2, E(K1,P)))
    - EDE provides DES compatibility, set K1 = K2.
  - 168 bit key
  - Slow implementations (DES was old)
- AES
  - 128/192/256 bit keys
  - 128 bit block
  - 4 steps, each reversible:
    - Byte Substitution
    - one S-box used on every byte
    - Shift Rows
    - permute bytes between columns
    - A circular left byte-shift
    - Mix Columns
    - permutation using matrix multiply
    - Add Round Key
    - XOR state with key material
  - all arithmetic done in GF(2^8)
# Block Mode
- ECB (Electronic Code Book)
  - Break text into blocks
  - Each block is then independently encrypted
  - Can rearrange blocks
- CBC (Cipher Block Chaining)
  - Break text into blocks
  - Ci = AES(K,(Pi XOR Ci-1))
    - XOR with previous(or IV) then encrypt
  - Pros
    - Tampering only works for first block
  - Cons
    - Needs entire sequence to encrypt
- CFB (Cipher FeedBack)
  - Ci = Pi XOR AES(K, Ci-1)
    - Encrypt the previous block then xor with plaintext
  - Pros
    - Parallelizable decryption
  - Cons
    - Error in transmission will propagate.
    - Needs entire sequence to encrypt
- OFB (Output FeedBack)
  - Ci= PiXOR Oi
  - Oi= AES(K, Oi-1)
    - Encrypt IV over and over
    - XOR encrypted values with plaintext
  - Pros
    - Can precompute all of the cipherbits
    - Errors will not propagate across blocks
  - Cons
    - Vulnerable to stream modification
    - If attacker knows plaintext Pi
    - Ci’ = Pi XOR Pi’ XOR Ci  
    - Never reuse a key.
    - XOR the cipher texts together and you get the xor of the
      plaintexts.
- CTR (Counter)
  - Ci = Pi XOR Oi
  - Oi = AES(K,i)
    - Encrypt some counter
    - Xor result with plaintext
  - Pros
    - Efficient, encryption and decryption can be parallelized
    - Allows for out of order encryption/decryption
  - Cons
    - Never reuse keys.
# Stream Cipher
- RC4
  - Fast and simple implementation
  - Never reuse keys
  - used in SSL/TLS, WEP
  - Key Scheduling
    - Maintain a state array of numbers from 0-255
    - Shuffle the state array using Key
  - Encryption
    - XOR state value with next byte to encrypt
# Public Key Cryptography
- Each user has 2 keys
  - Secret key
  - Public key
- Rely on one-way functions that are reverible given some key.
  - aka Trap Door functions
- Diffie-Hellman
  - DH setup
    - Agree in advance on
    - p(rime)
    - g(enerator)
    - Each user create
    - random private key (a < p)
    - computed public key (y_a = g^a mod p)
  - Shared key is then
    - g^{a x b} mod p
    - which is just y_a^{b} mod p or y_b^{a} mod p
    - both of these can be computed by Alice and Bob
  - Vulnerable to Man in the Middle attack
- RSA
  - Block cipher
  - Choose large primes p & q, n = p x q
  - Fermat's Theorem
    - a ^ p = a mod p
    - if a < p and p is prime
    - Test for compositeness, primeness is not necessarily true
    - can know a number is probably prime. or not prime.
  - Euler's Theorem
    - Totient function φ(n), phi(n), number of positive integers less than n
    - a^{φ(n)} mod n = 1
    - given two primes p and q where n = p x q
    - φ(n)=(p-1)(q-1) 
# Secure Hash Algorithms, MACs, Digital Signatures
- Requirements for a secure hash function
 1. Works for abritrary length messages
 2. easy/fast to compute hash
 3. produces a fixed length output
 4. given *hash* it's infeasible to find *original* message
   - Pre-image resistance
 5. given *original* message it's infeasible to find *another* message with the
 same hash
   - 2nd-pre-image resistance
 6. finding any two messages with the same hash is infeasible
   - strong ocllision resistance
- Hashing is weak to the birthday attack
 - 
